# 作业题

## 基础题

### 题目1 [加强训练]

#### 题干

请简述多进程使用的三大步骤及对应格式?

#### 参考答案

```properties
1.导包: import multiprocessing

2.创建对象: 对象名 = multiprocessing.Process(target=任务名)

3.使用对象开启进程: 对象名.start()
```





### 题目2 [加强训练]

#### 题干

请简述多线程使用的三大步骤及对应格式?

#### 参考答案

```properties
1.导包: import threading

2.创建对象: 对象名 = threading.Thread(target=任务名)

3.使用对象开启线程: 对象名.start()
```



### 题目3 [加强训练]

#### 题干

1.定义eat函数,接收参数a,for循环打印a次'干饭...'

2.定义study函数,接收参数a,for循环打印a次'学习...'

3.创建2个进程对象,分别给eat和study传递参数a的值为3

4.开启上述2个进程,并观察结果

#### 参考答案

```python
# 导包
import multiprocessing

# 任务1
def eat(a):
    for i in range(a):
        print('干饭...')

# 任务2
def study(a):
    for i in range(a):
        print('学习...')

# 多任务之多进程(注意: 加if判断是否是__main__)
if __name__ == '__main__':
    # 创建子进程对象 args:元组    kwargs:字典
    p1 = multiprocessing.Process(target=eat, args=(3,))
    p2 = multiprocessing.Process(target=study, kwargs={'a': 4})
    # 开启子进程
    p1.start()
    p2.start()

```



## 进阶题

### 题目1 [加强训练]

#### 题干

如何让子进程跟着主进程一起结束? 最好用代码演示

#### 参考答案

>方式1: 开启进程前设置子进程守护主进程 -> 子进程对象.daemon = True
>
>方式2: 强制终止子进程任务 -> 子进程对象.terminate()
>
>具体代码如下:
>
>```python
># 导包
>from multiprocessing import Process
>from time import sleep
>
>
># 子进程的任务
>def task():
>    for i in range(1, 11):
>        print(f'子进程中的任务正在进行中...{i}')
>        sleep(0.2)
>
>
># 多任务之多进程(抢)
>if __name__ == '__main__':
>    print('主进程的第一行代码...')
>    # 创建子进程对象
>    p = Process(target=task)
>    """
>    # 方式1: 开启进程前设置子进程守护主进程
>    p.daemon = True
>    """
>    # 开启进程(执行任务)
>    p.start()
>
>    # 为了效果明显,可以让主进程休息0.5秒,再执行最后一行代码
>    sleep(0.5)
>    print('主进程的最后一行代码...')
>
>    # 方式2: 主进程最后一行代码执行完后,强制终止子进程任务
>    p.terminate()
>```
>
>



### 题目2 [加强训练]

#### 题干

os模块如何获取进程的编号以及父进程编号?最好用代码演示

#### 参考答案

>获取当前进程的编号:   os.getpid()
>
>获取当前进程的父进程编号: os.getppid()
>
>具体代码如下:
>
>```python
># 导包
>import os
>import multiprocessing
>
># 任务1: 吃饭
>def eat():
>    print(f'eat子进程编号:{os.getpid()}')
>    print(f'eat父进程编号:{os.getppid()}')
>    print('干饭开始...')
>    print('干饭结束...')
>
>
># 任务2: 学习
>def study():
>    print(f'study子进程编号:{os.getpid()}')
>    print(f'study父进程编号:{os.getppid()}')
>    print('学习开始...')
>    print('学习结束...')
>
>
># 注意: 使用多进程方式,此处不能省略if __name__ == '__main__':
>if __name__ == '__main__':
>    print(f'main主进程编号:{os.getpid()}')
>    
>    # 多任务(抢): 充分利用cpu资源,同时执行多个任务,提高效率
>    # 创建进程对象: 注意任务名不要加()
>    p1 = multiprocessing.Process(target=eat)
>    p2 = multiprocessing.Process(target=study)
>    
>    # 开启进程(自动的同时执行对应的任务)
>    p1.start()
>    p2.start()
>
>```



## 面试题

### 题目1 [简答题]

#### 题干

并行和并发的区别 ?

#### 参考答案

```properties
- 并发：在一段时间内快速交替去执行多个任务（多线程）
- 并行：在一段时间内真正的同时一起执行多个任务（多进程）

并行：多个 CPU 同时执行多个任务，就好像有两个程序，这两个程序是真的在两个不同的 CPU 内同时被执行。
并发：CPU 交替处理多个任务，还是有两个程序，但是只有一个CPU，会交替处理这两个程序，而不是同时执行，只不过因为CPU执行的速度过快，而会使得人们感到是在“同时”执行，执行的先后取决于各个程序对于时间片资源的争夺

并行和并发同属于多任务，目的是要提高CPU的使用效率。这里需要注意的是，一个 CPU 永远不可能实现并行，即一个 CPU 不能同时运行多个程序，但是可以在随机分配的时间片内交替执行（并发），就好像一个人不能同时看两本书，但是却能够先看第一本书半分钟，再看第二本书半分钟，这样来回切换。
```





### 题目2 [简答题]

#### 题干

进程Process和线程threading区别 ?

#### 参考答案

```properties
- 进程（Process）
  - 是操作系统进行资源分配的基本单位
  - 进程可以有一个或多个子进程
  - 最原始的父进程是由操作系统提供的
- 线程（Thread）
  - 是CPU进行调度的基本单位
  - 线程可以有一个或多个子线程
  - 线程是由进程主动创建出来的，创建第一次创建子线程时才会出现主线程


1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（线程是计算机的最小单位）；

2.资源分配给进程，同一进程的所有线程共享该进程的所有资源，进程与进程之间资源相互独立，互不影响（类似深拷贝）;

3.多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程，多进程模式的缺点是在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题（进程的创建比线程的创建更加占用计算机资源）；

4.多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存；

5.由于GIL锁的缘故，python 中线程实际上是并发运行（即便有多个cpu，线程会在其中一个cpu来回切换，只占用一个cpu资源），而进程才是真正的并行（同时执行多个任务，占用多个cpu资源）
```

